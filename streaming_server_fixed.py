#!/usr/bin/env python3
"""
ÏàòÏ†ïÎêú MJPEG Ïä§Ìä∏Î¶¨Î∞ç ÏÑúÎ≤Ñ
ÌôîÎ©¥ Íπ®Ïßê Î¨∏Ï†ú Ìï¥Í≤∞
"""

import asyncio
import os
import subprocess
import signal
from pathlib import Path
from datetime import datetime
from typing import Generator
import threading
import time
from contextlib import asynccontextmanager
import uvicorn
from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse, HTMLResponse
from fastapi.middleware.cors import CORSMiddleware

# CORS ÎØ∏Îì§Ïõ®Ïñ¥Îäî lifespan Ïù¥ÌõÑÏóê Ï∂îÍ∞Ä

# Ï†ÑÏó≠ Î≥ÄÏàò
BASE_DIR = Path("/home/shinho/shinho/livecam")
VIDEO_DIR = BASE_DIR / "videos"
recording_processes = {}
streaming_processes = {}

# Ïä§Ìä∏Î¶¨Î®∏ Ïù∏Ïä§ÌÑ¥Ïä§ (Ï†ÑÏó≠ÏúºÎ°ú Ïù¥Îèô)
streamers = {}

class FixedMJPEGStreamer:
    """ÏàòÏ†ïÎêú MJPEG Ïä§Ìä∏Î¶¨Î∞ç ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, camera_id: int):
        self.camera_id = camera_id
        self.process = None
        self.is_streaming = False
        
    def start_stream(self):
        """Í∞úÏÑ†Îêú MJPEG Ïä§Ìä∏Î¶¨Î∞ç ÏãúÏûë"""
        if self.is_streaming:
            return
            
        # Îçî ÏïàÏ†ïÏ†ÅÏù∏ rpicam-vid Î™ÖÎ†π (ÎÖπÌôî ÏßÄÏõê)
        cmd = [
            "rpicam-vid",
            "--camera", str(self.camera_id),
            "--width", "640",
            "--height", "480", 
            "--timeout", "0",
            "--nopreview",
            "--codec", "mjpeg",
            "--quality", "85",
            "--framerate", "25", 
            "--bitrate", "0",
            "--denoise", "cdn_off",
            "--sharpness", "1.0",
            "--contrast", "1.0",
            "--saturation", "1.0",
            "--ev", "0",
            "--awb", "auto", 
            "--metering", "centre",
            "--flush", "1",
            "--output", "-"
        ]
        
        self.process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            bufsize=0  # Î≤ÑÌçºÎßÅ ÎπÑÌôúÏÑ±Ìôî
        )
        self.is_streaming = True
        streaming_processes[self.camera_id] = self.process.pid
        print(f"‚úÖ Camera {self.camera_id} streaming started (PID: {self.process.pid})")
        
    def get_fixed_frames(self) -> Generator[bytes, None, None]:
        """ÏàòÏ†ïÎêú MJPEG ÌîÑÎ†àÏûÑ ÏÉùÏÑ±Í∏∞"""
        if not self.is_streaming or not self.process:
            print(f"Starting stream for camera {self.camera_id}")
            self.start_stream()
            time.sleep(2)  # Ï¥àÍ∏∞Ìôî ÎåÄÍ∏∞
            
        if not self.process or self.process.poll() is not None:
            print(f"Process failed for camera {self.camera_id}")
            return
            
        buffer = bytearray()
        frame_count = 0
        
        try:
            while self.is_streaming and self.process and self.process.poll() is None:
                # Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
                chunk = self.process.stdout.read(16384)  # 16KB Ï≤≠ÌÅ¨
                if not chunk:
                    print(f"No data from camera {self.camera_id}")
                    time.sleep(0.1)
                    continue
                    
                buffer.extend(chunk)
                
                # ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú
                while True:
                    start_idx = buffer.find(b'\xff\xd8')
                    if start_idx == -1:
                        # Î≤ÑÌçº ÌÅ¨Í∏∞ Ï†úÌïú
                        if len(buffer) > 100000:
                            buffer = buffer[-50000:]
                        break
                        
                    end_idx = buffer.find(b'\xff\xd9', start_idx + 2)
                    if end_idx == -1:
                        if len(buffer) > 200000:  # 200KB Ï†úÌïú
                            buffer = buffer[start_idx:]
                            if len(buffer) > 100000:
                                buffer = buffer[:100000]
                        break
                        
                    # ÏôÑÏ†ÑÌïú ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú
                    frame = bytes(buffer[start_idx:end_idx + 2])
                    buffer = buffer[end_idx + 2:]
                    
                    # ÏµúÏÜå ÌîÑÎ†àÏûÑ ÌÅ¨Í∏∞ Ï≤¥ÌÅ¨
                    if len(frame) < 1024:  # 1KB ÎØ∏ÎßåÏùÄ Ïä§ÌÇµ
                        continue
                        
                    frame_count += 1
                    
                    # MJPEG Î©ÄÌã∞ÌååÌä∏ ÏùëÎãµ ÏÉùÏÑ±
                    yield (
                        b'--frame\r\n'
                        b'Content-Type: image/jpeg\r\n'
                        b'Content-Length: ' + str(len(frame)).encode() + b'\r\n'
                        b'\r\n' + frame + b'\r\n'
                    )
                    
        except Exception as e:
            print(f"Error in camera {self.camera_id}: {e}")
        finally:
            print(f"Stream ended for camera {self.camera_id}")
                
    def stop_stream(self):
        """Ïä§Ìä∏Î¶¨Î∞ç Ï§ëÏßÄ"""
        self.is_streaming = False
        if self.process:
            self.process.terminate()
            try:
                self.process.wait(timeout=3)
            except:
                self.process.kill()
            if self.camera_id in streaming_processes:
                del streaming_processes[self.camera_id]
            print(f"‚èπÔ∏è Camera {self.camera_id} streaming stopped")

@asynccontextmanager
async def lifespan(app: FastAPI):
    """ÏÑúÎ≤Ñ ÎùºÏù¥ÌîÑÏÇ¨Ïù¥ÌÅ¥ Í¥ÄÎ¶¨"""
    # Startup
    print("üöÄ Fixed Streaming Server Started")
    VIDEO_DIR.mkdir(parents=True, exist_ok=True)
    
    # Ïä§Ìä∏Î¶¨Î®∏ Ï¥àÍ∏∞Ìôî
    streamers[0] = FixedMJPEGStreamer(0)
    streamers[1] = FixedMJPEGStreamer(1)
    
    # Ïä§Ìä∏Î¶¨Î∞ç ÏãúÏûë (ÏàúÏ∞®Ï†ÅÏúºÎ°ú)
    for cam_id, streamer in streamers.items():
        try:
            streamer.start_stream()
            await asyncio.sleep(1.0)  # Ï∂©Î∂ÑÌïú Í∞ÑÍ≤©
        except Exception as e:
            print(f"‚ùå Failed to start camera {cam_id}: {e}")
    
    yield  # ÏÑúÎ≤Ñ Ïã§Ìñâ Ï§ë
    
    # Shutdown
    for streamer in streamers.values():
        streamer.stop_stream()
    
    for pid in recording_processes.values():
        try:
            os.kill(pid, signal.SIGINT)
        except:
            pass
    print("üëã Server stopped")

# FastAPI Ïï± ÏÉùÏÑ± (lifespan Ï†ÅÏö©)
app = FastAPI(title="Fixed Blackbox Streaming Server", lifespan=lifespan)

# CORS ÏÑ§Ï†ï
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def root():
    """Ïõπ UI"""
    html_content = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Fixed Blackbox Streaming</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            * { margin: 0; padding: 0; box-sizing: border-box; }
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
                color: #fff;
                padding: 20px;
            }
            .container { max-width: 1400px; margin: 0 auto; }
            h1 {
                text-align: center;
                margin-bottom: 30px;
                font-size: 2rem;
                background: linear-gradient(90deg, #4CAF50, #45a049);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
            }
            .camera-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
                gap: 20px;
            }
            .camera-box {
                background: rgba(255,255,255,0.05);
                border: 1px solid rgba(255,255,255,0.1);
                border-radius: 12px;
                padding: 15px;
                backdrop-filter: blur(10px);
            }
            .camera-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
            }
            .camera-title { 
                font-size: 1.2rem;
                font-weight: 600;
            }
            .status-badge {
                padding: 4px 12px;
                border-radius: 20px;
                font-size: 0.85rem;
                background: rgba(76, 175, 80, 0.2);
                color: #4CAF50;
                border: 1px solid #4CAF50;
            }
            .video-container {
                position: relative;
                width: 100%;
                padding-bottom: 75%;
                background: #000;
                border-radius: 8px;
                overflow: hidden;
            }
            .video-stream {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                object-fit: contain;
            }
            .controls {
                margin-top: 15px;
                display: flex;
                gap: 10px;
            }
            button {
                flex: 1;
                padding: 10px;
                background: linear-gradient(135deg, #4CAF50, #45a049);
                color: white;
                border: none;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 600;
                transition: transform 0.2s;
            }
            button:hover { transform: translateY(-2px); }
            button:active { transform: translateY(0); }
            button.stop {
                background: linear-gradient(135deg, #f44336, #da190b);
            }
            .info {
                margin-top: 10px;
                padding: 10px;
                background: rgba(255,255,255,0.03);
                border-radius: 6px;
                font-size: 0.9rem;
                color: #aaa;
            }
            .loading {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #4CAF50;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üé• Fixed Blackbox Streaming System</h1>
            
            <div class="camera-grid">
                <div class="camera-box">
                    <div class="camera-header">
                        <div class="camera-title">üìπ Camera 0</div>
                        <div class="status-badge" id="status0">Streaming</div>
                    </div>
                    <div class="video-container">
                        <img class="video-stream" id="stream0" alt="Camera 0">
                        <div class="loading" id="loading0">Loading...</div>
                    </div>
                    <div class="controls">
                        <button onclick="startRecording(0)">‚ñ∂Ô∏è Record</button>
                        <button class="stop" onclick="stopRecording(0)">‚èπÔ∏è Stop</button>
                        <button onclick="reconnect(0)">üîÑ Reconnect</button>
                    </div>
                    <div class="info">640√ó480 @ 25fps | MJPEG 85% Quality</div>
                </div>
                
                <div class="camera-box">
                    <div class="camera-header">
                        <div class="camera-title">üìπ Camera 1</div>
                        <div class="status-badge" id="status1">Streaming</div>
                    </div>
                    <div class="video-container">
                        <img class="video-stream" id="stream1" alt="Camera 1">
                        <div class="loading" id="loading1">Loading...</div>
                    </div>
                    <div class="controls">
                        <button onclick="startRecording(1)">‚ñ∂Ô∏è Record</button>
                        <button class="stop" onclick="stopRecording(1)">‚èπÔ∏è Stop</button>
                        <button onclick="reconnect(1)">üîÑ Reconnect</button>
                    </div>
                    <div class="info">640√ó480 @ 25fps | MJPEG 85% Quality</div>
                </div>
            </div>
        </div>
        
        <script>
            let reconnectAttempts = {};
            
            // Ïä§Ìä∏Î¶º Ï¥àÍ∏∞Ìôî
            function initStream(camId) {
                const img = document.getElementById(`stream${camId}`);
                const loading = document.getElementById(`loading${camId}`);
                
                reconnectAttempts[camId] = 0;
                
                img.src = `/stream/${camId}?t=${Date.now()}`;
                
                img.onload = () => {
                    loading.style.display = 'none';
                    reconnectAttempts[camId] = 0;
                };
                
                img.onerror = () => {
                    loading.style.display = 'block';
                    loading.textContent = 'Connection lost. Retrying...';
                    
                    // ÏûêÎèô Ïû¨Ïó∞Í≤∞ (ÏµúÎåÄ 5Ìöå)
                    if (reconnectAttempts[camId] < 5) {
                        reconnectAttempts[camId]++;
                        setTimeout(() => reconnect(camId), 3000);
                    } else {
                        loading.textContent = 'Connection failed. Click Reconnect.';
                    }
                };
            }
            
            // Ïû¨Ïó∞Í≤∞
            function reconnect(camId) {
                const img = document.getElementById(`stream${camId}`);
                const loading = document.getElementById(`loading${camId}`);
                loading.style.display = 'block';
                loading.textContent = 'Reconnecting...';
                
                img.src = '';
                setTimeout(() => {
                    img.src = `/stream/${camId}?t=${Date.now()}`;
                }, 500);
            }
            
            // ÎÖπÌôî Ï†úÏñ¥
            async function startRecording(camId) {
                try {
                    const response = await fetch(`/record/start/${camId}`, {method: 'POST'});
                    const data = await response.json();
                    document.getElementById(`status${camId}`).textContent = 'Recording';
                    document.getElementById(`status${camId}`).style.background = 'rgba(244, 67, 54, 0.2)';
                    document.getElementById(`status${camId}`).style.color = '#f44336';
                    document.getElementById(`status${camId}`).style.borderColor = '#f44336';
                } catch (e) {
                    console.error('Recording start failed:', e);
                }
            }
            
            async function stopRecording(camId) {
                try {
                    const response = await fetch(`/record/stop/${camId}`, {method: 'POST'});
                    const data = await response.json();
                    document.getElementById(`status${camId}`).textContent = 'Streaming';
                    document.getElementById(`status${camId}`).style.background = 'rgba(76, 175, 80, 0.2)';
                    document.getElementById(`status${camId}`).style.color = '#4CAF50';
                    document.getElementById(`status${camId}`).style.borderColor = '#4CAF50';
                } catch (e) {
                    console.error('Recording stop failed:', e);
                }
            }
            
            // ÏûêÎèô Ïû¨Ïó∞Í≤∞ ÌÉÄÏù¥Î®∏ (5Î∂ÑÎßàÎã§)
            setInterval(() => {
                for (let i = 0; i <= 1; i++) {
                    const img = document.getElementById(`stream${i}`);
                    if (img && img.complete && img.naturalWidth === 0) {
                        reconnect(i);
                    }
                }
            }, 300000);
            
            // Ï¥àÍ∏∞ Î°úÎìú
            window.onload = () => {
                setTimeout(() => initStream(0), 100);
                setTimeout(() => initStream(1), 500);
            };
        </script>
    </body>
    </html>
    """
    return HTMLResponse(content=html_content)

@app.get("/stream/{camera_id}")
async def stream_camera(camera_id: int):
    """ÏàòÏ†ïÎêú MJPEG Ïä§Ìä∏Î¶¨Î∞ç ÏóîÎìúÌè¨Ïù∏Ìä∏"""
    if camera_id not in streamers:
        raise HTTPException(status_code=404, detail="Camera not found")
    
    return StreamingResponse(
        streamers[camera_id].get_fixed_frames(),
        media_type="multipart/x-mixed-replace; boundary=frame",
        headers={
            "Cache-Control": "no-cache, no-store, must-revalidate",
            "Pragma": "no-cache",
            "Expires": "0",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no"
        }
    )

@app.post("/record/start/{camera_id}")
async def start_recording(camera_id: int):
    """ÎÖπÌôî ÏãúÏûë - Ïä§Ìä∏Î¶¨Î∞çÍ≥º Ïπ¥Î©îÎùº Ï∂©ÎèåÎ°ú ÌòÑÏû¨ Î∂àÍ∞ÄÎä•"""
    return {
        "status": "Error: Camera resource conflict", 
        "camera": camera_id,
        "message": "Ïä§Ìä∏Î¶¨Î∞ç Ï§ëÏóêÎäî Î≥ÑÎèÑ ÎÖπÌôî Î∂àÍ∞ÄÎä•. Ïä§Ìä∏Î¶¨Î∞çÏùÑ Ï§ëÎã®ÌïòÍ≥† start_blackbox.shÎ•º ÏÇ¨Ïö©ÌïòÍ±∞ÎÇò, Ìñ•ÌõÑ tee Î∞©Ïãù Íµ¨ÌòÑ ÏòàÏ†ï"
    }

@app.post("/record/stop/{camera_id}")
async def stop_recording(camera_id: int):
    """ÎÖπÌôî Ï§ëÏßÄ"""
    if camera_id not in recording_processes:
        return {"status": "Not recording", "camera": camera_id}
    
    pid = recording_processes[camera_id]
    try:
        os.kill(pid, signal.SIGINT)
        del recording_processes[camera_id]
        return {"status": "Recording stopped", "camera": camera_id}
    except Exception as e:
        return {"status": f"Error: {e}", "camera": camera_id}

@app.get("/status")
async def system_status():
    """ÏãúÏä§ÌÖú ÏÉÅÌÉú"""
    return {
        "streaming": list(streaming_processes.keys()),
        "recording": list(recording_processes.keys()),
        "pids": {
            "streaming": streaming_processes,
            "recording": recording_processes
        }
    }

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")